Техника оптимизации составного свойства border.

Стандарт CSS определяет множетсво составных свойств: border, background, transition, font, margin, padding, ...
Составные свойства имеют довольно сложный набор подчиненных свойств (наример, тот же border - 12),
каждое из которых определяет собственные правила для своих значений и формы их записи.
Учитывая весь этот зоопарк - оптимизация таких свойств то еще "проклятие".
Но это делает возможным довольно любопытные приемы минимизации исходного CSS-текста.
Какие? На примере border мы попробуем отработать эти приемы и определить ситуации, когда они применимы.

Одной единственной инструкцией border можно задать сразу и цвет, и толщину и внешний вид границы элемента.
Минимально возможная форма инструкции: border:solid, которая определяет вокруг элемента сплошной контур
черного цвета (цвет "по умолчанию"), шириной medium (ширина "по умолчанию"). Но мало кого из дизайнеров
устраивает такой вариант. На самом деле наиболее востребованной и краткой формой записи свойства border является:
border: solid 1px red;

На самом деле мы только что определили группу из 12 css-свойств элемента. Вот они все:
   border-top-style: solid;
 border-right-style: solid;
border-bottom-style: solid;
  border-left-style: solid;
   border-top-width: 1px;
 border-right-width: 1px;
border-bottom-width: 1px;
  border-left-width: 1px;
   border-top-color: red;
 border-right-color: red;
border-bottom-color: red;
  border-left-color: red;
Порядок следования сторон top, right, bottom, left здесь не случаен. По часовой стрелке сверху. Так определено в стандарте.




Предположим, что в данном css-классе дизайнеру нужно установить только стиль верхней границы.
А общее свойство border задается в другом классе. Наше же лишь дополняет его.
Тогда самой краткой формой будет:
border-top-style: dotted;				(1) только одно свойство определено

А если таких свойств будет уже два? Можно ли сократить?
Да. Существует чуть более краткая форма записи для этого случая.
Предположим, что мы еще перепределяем стиль правой границы:
border-top-style: dotted;
border-right-style: double;
Такое можно сократить до:
border-style:dotted double none none;			(2а) два или три свойства определены

Хорошо. Хорошо. А по-короче можно?
Ответ зависит от того, какие именно свойства и как будут устанавливаться.
Например, если нам нужно поменять стиль верхней и нижней границ, причем на один и тот же:
border-top-style: dotted;
border-bottom-style: dotted;
Тогда мы можем записать это так:
border-style:dotted none;				(2б) только противоположные стороны определены

Ну или определяем ширину левой и правой границы одним и тем же значением:
border-left-width: 3px;
border-right-width: 3px;
Мы можем аналогично записать это как:
border-width: 0 3px;					(2б) только противоположные стороны определены

Правда вот запарочка. Мы здесь уже своевольничаем. Задавать значения none и 0 для остальных сторон нас никто не просил.
Да. Всё понятно. В этом классе это будет работать. Но не надо забывать, что классы работают вместе и каскадно.
Не факт, что в другом классе стиль всех границы этого же элемента тоже не определяется. Накладочка выйдет.

Кроме этого. Для цвета такой трюк не подходит. В стандате нет константы, обозначающей отсутствующий цвет.
А значит нам использовать такую форму записи для цвета нельзя. 
Мы, конечно, можем использовать прозрачный цвет rgba(0,0,0,0). Но это только сделает наш текст длиннее.
А мы же стремимся его сократить?

Но не все так плохо. Мы можем "посвоевольничать" в том случае, если в этом же классе присутствует общая форма border.
Тогда мы можем использовать вместо none и 0 реально определенные значения из border. А сами значения из него убрать.
Давайте соединим два последних случая вместе например так:
border: solid 1px red;
border-top-style: dotted;
border-bottom-style: dotted;
border-left-width: 3px;
border-right-width: 3px;
Это все можно оптимизировать так:
border: red;						(2в) противоположные стороны + общая форма double
border-style: dotted solid;
border-width: 3px 1px;
Как результат - уменьшение текста в 2 раза.
И да. такой подход будет работать с цветом тоже.


Теперь будем рассматривать ситуации, когда неопределенных свойств нет. Возмьмем похожую ситуацию,
когда стиль верхней границы отличается от остальных:
border-top-style: solid;
border-right-style: groove;
border-bottom-style: groove;
border-left-style: groove;

Тогда наиболее краткой формой записи будет квартетом:
border-style:solid groove groove groove;		(3а) одно или несколько из 4-х свойств отличается

Логично, что для 2-х отличных свойств этот вариант оптимизации будет наилучшим,
но только в том, случае, если имя повторяемого свойства не превышает 7-ти символов.
И чем меньше длина повторяемого свойства, тем лучше оптимизация.
К счастью, именованные константы стилей границ и их длин не длиннее 7-ми символов.
А что касается констант цветов - то их можно сократить до шеснадцатиричной формы #rrggbb,
которая как раз таки 7-ми символьная.

Но если в классе присутствует общая форма border:
border:3px red;
border-top-style: solid;
border-right-style: groove;
border-bottom-style: groove;
border-left-style: groove;

То можно оптимизировать вот так:
border:3px red groove;border-top-style:solid;		(3б) одно из 4-х свойств отличается + общая форма

Но можно это еще укоротить, если отличаются противоположные стороны:
border-top-style: solid;
border-bottom-style: solid;
border-left-style: groove;
border-right-style: groove;

Оптимизация будет такой:
border-style: solid groove;				(4) противоположные стороны double

С общей формой border эта оптимизация равна (2в).

Ну и, наконец, если стиль/цвет/ширина правой и левой границ совпадают:
border-top-style: solid;
border-right-style: groove;
border-bottom-style: dashed;
border-left-style: groove;


Можно это записать вот так:
border-style: solid groove dashed;			(5) правая и левая границы эквивалентны  tripple

Кстати, триплет, не самая лучшая идея для оптимизации для той ситуации, когда длина свойства левой стороны 6+. Вот примеры:

border-color:tan tan red;				tripple лучше, 3
 tan;border-left-color:red;

border-color:aqua aqua red;				tripple лучше, 4
 aqua;border-left-color:red;

border-width:thin thin medium;				tripple лучше, 4
 thin;border-left-width:medium;

border-width:thick thick thin;				tripple эквивалентно, 5
 thick;border-left-width:thin;

border-width:medium medium thin;			tripple хуже, 6
 medium;border-left-width:thin;

border-color:aquamarine aquamarine red;			tripple хуже, 10
 aquamarine;border-left-color:red;

Особый случай, который требует включения свойства 






А попробуем длинное название цвета:
border-color:magenta;border-top-color:red;
border-color:red magenta magenta magenta;

первый вариант добавляет от 15 доп символов border-*-color:* + от 3-х на название свойства (top, left);
второй вариант добавляет length(magenta)*2 + 1 доп. символов = 17





---
ВРЕЗКА
---
Я забыл про border-top: solid 1px red;

Сравним:
border-style:solid dashed dotted double;border-width:1px 2px 3px 4px;border-color:red green lime yellow;
border-top:solid 1px red;border-right:dashed 2p green;border-bottom:dotted 3px lime;border-left:double 4px yellow;
---
ВРЕЗКА
---




------------------------------
Есть правда одна загвоздка при оптимизации свойтсв вообще.
Мы не можем сократить это:
border: red;
border: rgba(255,0,0,0.5);
т.е. приемы, применяемые для совместимости браузеров.
А значит, объединяя разные описания border в одну переменную, мы должны учитывать совместимость этих описаний.
