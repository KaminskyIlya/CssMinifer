Экстремальная минификация CSS с турбонадувом.

Казалось бы, что может быть проще минификации таблицы стилей?
Удалил все комментарии, лишние пробелы, переносы строк и точки с запятой. И всё: дело сделано; достигнут предел возможного.
Хотя, стоп. Нет. Продвинутый yuicompressor (http://yui.github.io/yuicompressor/css.html) преобразует все rgb/hsl-выражения в шестнадцатиричный эквивалентный вид,
уберет нули перед началом дробных чисел, и сделает еще несколько хитрых манипуляций, выдавая вам в итоге чуть более компактный файл.
После такого минификатора сжимать что либо еще в ccs-файле уже не реально. Или реально?

+-----------------------------+
|  О трюках минификации CSS   |
+-----------------------------+

Так думали мы и довольствовались возможностями этой утилиты до тех пор, пока конечный размер выдаваемых клиенту ресурсов не стал краегольным камнем нашего проекта.

Идея написать свой минификатор с блекджеком и удобствами (точнее доработать существующий) пришла, конечно, не сразу. Во всем виноваты дизайнеры.
Дело в том, что наши дизайнеры уже давно проектируют макеты в концепции резиновой адаптивной разметки.
Особенность разработки адаптивного дизайна заключается в том, что вам для каждого компонента приходится делать не одну версию, а сразу несколько, под популярные разрешения экранов.
Типичный файл стилей компонента выглядит так:....

При таком подходе, сборка и компиляция всех css/less/sass файлов в единый блок, приводит к тому, что медиазапросы многократно повторяются.
Что влияет как на размер файла (главным образом), так и на производительность парсера браузера.
**К сожалению, ни один минификатор, не группирует медиазапросы с одинаковыми выражениями. А жаль. - переделать

Сделать такую группировку не составляет труда (правда есть некоторые но?*). И мы быстро сделали соответствующий постпроцессор.
В сочетании со стандартным минификатором, это стало давать неплохие результаты: 250Кб стилей вмиг ужались до 187Кб. Что само по себе круто.
Но у нас проснулся спортивный интерес: а можно ли еще придумать неколько трюков, чтобы повысить степень уменьшения?
-И-тут-Остапов-понесло- Вот об этих трюках ниже и пойдет речь.


Первая атака пошла на числа. Меня лично уже давно раздражала bootstrap'овская система разметки, с ее стилями вида: .col-xs-11{width:91.66666667%}
К чему такая гигантская точность? Ведь даже округлив такое число до 2-х знаков после запятой, мы получим погрешность в расчетах не более 1 пикселя на каждые 10000.
Т.е. на экране с разрешением 15000 пикселей вы увидите в верстке артефакт шириной в один пиксель (хотя увидите ли: это еще тот вопрос).
Вряд ли у вас будет экран с таким разрешением (мы сейчас закроем глаза на экраны высокой плотности у смартфонов и планшетов; но они декларируют свое разрешение много ниже реального).
Конечно, виноваты тут не разработчики упомянутого фреймворка, а less-компилятор, который бездумно раздувает вещественные числа.
Поэтому преобразование: 91.66666667 до 91.67% можно считать эквивалентным. Но если вас беспокоит та самая погрешность, можете увеличить точность до еще одно разряда.

Вторая группа идей была связана с цветом.
Конечно, обычный минификатор, уже, казалось бы все сделал: перевел rgb/hsl-выражения, преобразовал цвета вида #777777 в #777, даже заменил длинные цветовые константы на
более короткие эквивалентные числа. Жаль, что разработчики css не придумали сокращения для rgba/hsla-выражений.
Зато мы подметили следующую вещь: большинство людей не отличит оттенок цвета #80705e от оттенка #876 (#887766). Только если не поставить рядом две большие области,
окрашенные в эти оттенки. А вот текст и границы элементов, даже будучи поставленные рядом, вообще не отличить (хотя на сочных SuperAMOLET экранах смартфонов таки
можно разглядеть разницу). В общем, мы решили для текста и границ использовать 4K цветовую модель, вместо 16M. В итоге, каждый пожатый оттенок уменьшается еще на 3 байта.
Как гласит пословица, один бит целый байт бережет.

Третья группа идей связана с текстовыми идентификаторами.
Мало кто задумывается, но в инструкции @font-face(font-family:'...') можно писать любой удобный для вас идентификатор?*. А если он не содержит пробелов, - кавычки можно опустить.
Затем, этот идентификатор можно использовать в стилях: h1{font-family:...) также без кавычек. Мелочь, а приятно.
Подходит для сайтов, использующих несколько фирменных шрифтов. В обычных сайтах инструкции font-family встречаются очень редко.
Правда есть одно но: такой подход работает, если вы не используете inline-стили вообще. Иначе будете удивлены тем, что ваш шрифт NissanCY MediumExt теперь называется как N.
Такая же участь постигла названия анимаций:  @keyframe name { }, где name можно сократить до одной-двух букв. А заодно и ключевое слово from можно заменить на 0%.

Четвертая группа идей связана с комплексными составными свойствами.
Стандарт CSS 3-й, действующей версии (а уже на подходе 4-я), настолько сложен, что вариантов написания одних и тех же эквивалентных конструкций существует достаточно много.
А значит и маневров для оптимизаций хватает. Комплескными составными свойствами являются: font, border, background, animation, transition, margin, padding и еще много других.
У таких свойств множество подчиненных свойств, и каждое из них может быть изменено независимо. Кроме этого, у большинства подчиненных свойств есть значения по умолчанию.
Для примера, возьмем всем известное свойство border. Пожалуй это одно из самых сложных комплексных свойств из всех. И вот почему.
Наиболее часто встречаемой формой записи этого свойства является такая: border: solid 1px red;
Но на самом деле мы только что установили 12(!) независимых значений.

Грамотное использование значений по умолчанию может тоже дать результат. Например, border: solid 1px black; эквивалентен border: solid 1px;
При 2-х условиях: на данный стиль не влияет другой класс; black - это "дефолтный" текущий цвет для html. для SVG он может быть переопределен.

По принципу оптимизации комплексных свойств можно трансформировать функции linear-gradient, ... чтобы добиться наиболее компактного представления.
Там можно переставлять местами аргументы, сокращая запись.


Про !important

Ну про подстановки некоторых ключевых слов всем изместно.
Например, тот же yiucompressor заменяет инструкцию border:none на эквивалентную border:0.










Знаете ли вы, что один и тот же файл стилей, одним и тем же компрессором (zip, gzip, bzip) может быть сжат по разному?
Простая перестановка стилевых правил внутри файла может привести к увеличению степени сжатия.
Конечно, мы будем сжимать не один и тот же файл, а два разных. Но семантически они будут эквивалентны.
Вся хитрость тут в особенностях работы сжимающих алгоритмов.











---Причиной разочарования в стандартных минификаторах послужило сразу несколько факторов.

Во-первых, основная целевая аудитория проекта - пользователи мобильных платформ. Как правило, это люди, выходящие в интернет через сотовые телефоны (реже планшеты),
посредством GSM-модемов. Мобильный интернет славится своей скоростью и устойчивостью. Особенно за пределами МКАД. А в нашем регионе 32Кб\с при пинге < 500мс - это неслыханная скорость.
Поэтому, берясь за разработку нашего проекта с учетом всех требований ТЗ, мы понимали, что за каждый байт нам придется не только бороться, но и биться до последней капли крови.

Во-вторых, ориентированность на браузеры мобильных устройств при требовании обязательной поддержки также и десктопных браузеров
практически не оставила нам выбора в подходе к дизайну: исключительно адаптивная верстка. Ни каких альтернативных представлений. И точка.
Надо сказать, последнее требование не вызвало у нас какого либо шока. Наши дизайнеры уже давно проектируют макеты с учетом резиновой адаптивной разметки.
(Порой мне кажется, что заставь их делать классический сайт "кирпичем", как они впадут в ступор от самой постановки задачи)

Особенность разработки адаптивного дизайна заключается в том, что вам для каждого компонента приходится делать не одну версию, а сразу несколько, под популярные разрешения экранов.
Типичный файл стилей компонента выглядит так:
...
общие стили для всех экранов, без учета их размеров
(шрифт, цвет, границы,...)
...
@media (max-width: @phone-size)
{
... небольшой тюнинг для сотовых телефонов...
    (например, уменьшение шрифта, удаление лишних отступов,
     скрытие не несущих смысловой нагрузки изображений и т.п.)
}
@media (max-width: @tablet-size)
{
... переопределение стилей для планшетов...
}
@media (max-width: @notebook-size)
{

}
@media (min-width: @fullHD-size)
{
...
}

При таком подходе, сборка и компиляция всех css файлов в единый блок, приводит к тому, что медиазапросы многократно повторяются.
Что влияет как на размер файла (главным образом), так и на производительность парсера браузера.
К сожалению, ни один минификатор, не группирует медиазапросы с одинаковыми выражениями. А зря.
