Переписать ReaderTokenizer - работает неправильно для CssSelector
Нужен похожий Tokenizer, но работающий на регулярке \s*[+~>]\s*
Либо добавить в него соответствующие методы (см. образец из org.w3c.utils.css.io.ProcessedBuffer#replaceAll)

Дописать тесты для Qualifier - проверять получаемую модель;
прогнать все спецификации CssSelector согласно документации.

Сделать модель для PseudoClass в Qualifier
odd = 2n+1, 2n = even, 2n+0 = 2n, 0n+5 = 5, 1n+0 = n, -1n+0 = -n, ( -n+ 6 ) - valid, ( + 2n ) - invalid
Выписать сюда все псевдоклассы.

Без аргументов:
:fist-child
:last-child
:before, :after

С аргументами
:nth-child(an+b)
:not(qualifier)



Написать тест на CssTextTokenizer

Переходить к реализации задуманных ранее парсеров: (нужно доделать модель SelectorList, MediaExpression CssPage).
Не забывать, что к любой значимой модели нужно добавлять информацию о ее позиции в тексте.
Между прочим реализация MediaQueryParser будет очень напоминать SelectorsListParser (потребуется также доделать модели)

Вообще, там где добавляется новый объект к общей модели (например, CssDocument + CssPage) нужно создавать специальные методы.
Например,
CssPage page = CssDocument.checkExistsPage(media_query);
if ( page == null )
{
  page = new CssPage(media_query);
  CssDocument.getPages().add(page);
}
Зачем? В таком специальном методе мы будем проверять, не существует ли подобные объекты:
- страницы с одинаковыми медиазапросами
- объявления с одинаковыми селекторами
и т.п.
Иначе, можно пролететь, если использовать родные hashCode vs. equals и HashSet.
Ведь модель меняется по ходу парсинга, а значит и меняются ее хэш. А значит будет ошибка...

Кстати. Не забыть про важную деталь при создании модели.
Когда модель будет рендериться в итоговый файл, порядок следования объявлений селекторов важен.
Он должен совпадать исходному коду. Хотя и может меняться интелектуальным оптимизатором.
Нужен механизм упорядочивания селекторов (использовать LinkedHasSet или ArrayList).
В классе CssPage необходимо использовать упорядоченный Set<>



org.w3c.utils.css.model.at.Media
Проверить парсинг медиазапросов - уточнить их формат в спецификации.
Чуть изменить модель конъюнкций и условий

Зачем нужно создавать модель медиазапросов?
Чтобы сравнивать медиазапросы с одинаковыми условиями, но записанные по разному:

@media (min-width: 550px) and (max-width: 800px);
@media (max-width: 800px) and (min-width: 550px);

@import "file" tv, screen and (color) and (min-width: 550px)
                              ^^^^^^      ^^^^^^^^^^^^^^^^^^ - conditions
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ - expression
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ - media query
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ - expressions list




Сделать поиск паттерна в потовряющихся классах (на вход подается список имен)
.col-xs-1, .col-xs-2, .col-xs-3   =>  [class^='col-xs-']
.fa-event-icon .fa-book-icon .fa-save-icon  => [class$='-icon']
.btn-danger-mini, .btn-danger-large, .label-danger-mini, .btn-danger-large => [class*='-danger-']








Пока отказаться от идеи трансформации текста css в упрощенный вариант с токенами (токенизация).
Сложности и вопросы.
Как это реализовать?
1. поменять текст при помощи RecycledCharBuffer? но в нем может быть переполнение из-за коротких селекторов.
   плюс для поиска необходимо применять сложные регулярные выражения.
   плюс потом будет непонятно как анализировать токены с привязкой к исходному тексту
2. создать новый текст на базе исходного?
   придется парсить линейно
Как реализовать кодировку символов @charset "<name>"?
При этом на все равно придется так или иначе знать о том, что именно мы заменяем.
Например остаются сложности с медиазапросами; блоками стилей и т.п.